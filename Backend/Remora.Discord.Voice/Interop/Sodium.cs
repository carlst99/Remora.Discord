//
//  Sodium.cs
//
//  Author:
//       Jarl Gullberg <jarl.gullberg@gmail.com>
//
//  Copyright (c) 2017 Jarl Gullberg
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

using System;
using System.Runtime.InteropServices;
using JetBrains.Annotations;
using Remora.Discord.Voice.Errors;
using Remora.Results;

#pragma warning disable SA1300 // Element should begin with upper-case letter

namespace Remora.Discord.Voice.Interop
{
    /// <summary>
    /// Represents an interface to the native libsodium library.
    /// </summary>
    public sealed unsafe partial class Sodium
    {
        private const string SodiumLibraryName = "libsodium";

        [DllImport(SodiumLibraryName, CallingConvention = CallingConvention.Cdecl)]
        private static extern IntPtr sodium_version_string();

        [DllImport(SodiumLibraryName, CallingConvention = CallingConvention.Cdecl)]
        private static extern uint crypto_secretbox_xsalsa20poly1305_keybytes();

        [DllImport(SodiumLibraryName, CallingConvention = CallingConvention.Cdecl)]
        private static extern uint crypto_secretbox_xsalsa20poly1305_noncebytes();

        [DllImport(SodiumLibraryName, CallingConvention = CallingConvention.Cdecl)]
        private static extern uint crypto_secretbox_xsalsa20poly1305_macbytes();

        /// <summary>
        /// Encrypts a messages using the xsalsa20_poly1305 algorithm.
        /// </summary>
        /// <param name="output">Output buffer for the encrypted data.</param>
        /// <param name="message">The message to encrypt.</param>
        /// <param name="messageLength">The length of the message.</param>
        /// <param name="nonce">The nonce to use.</param>
        /// <param name="key">The key to use.</param>
        /// <returns>Zero on success, else -1.</returns>
        [DllImport(SodiumLibraryName, CallingConvention = CallingConvention.Cdecl)]
        private static extern int crypto_secretbox_easy(byte* output, byte* message, ulong messageLength, byte* nonce, byte* key);
    }

    [PublicAPI]
    public sealed partial class Sodium
    {
        private static ReadOnlyMemory<byte> _keyBytes;

        /// <summary>
        /// Gets the version of the underlying sodium library.
        /// </summary>
        public static readonly string? Version = Marshal.PtrToStringAnsi(sodium_version_string());

        /// <summary>
        /// Gets the size of the key expected by the xsalsa20_poly1305 algorithm.
        /// </summary>
        public static readonly uint KeySize = crypto_secretbox_xsalsa20poly1305_keybytes();

        /// <summary>
        /// Gets the size of nonce expected by the xsalsa20_poly1305 algorithm.
        /// </summary>
        public static readonly uint NonceSize = crypto_secretbox_xsalsa20poly1305_noncebytes();

        /// <summary>
        /// Gets the size of MAC generated by the xsalsa20_poly1305 algorithm.
        /// </summary>
        public static readonly uint MacSize = crypto_secretbox_xsalsa20poly1305_macbytes();

        private Sodium(ReadOnlyMemory<byte> keyBytes)
        {
            _keyBytes = keyBytes;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Sodium"/> class.
        /// </summary>
        /// <param name="keyBytes">The key bytes to encode data with.</param>
        /// <returns>The created <see cref="Sodium"/> instance, or an error if the initialization failed.</returns>
        public static Result<Sodium> Create(ReadOnlyMemory<byte> keyBytes)
        {
            if (keyBytes.Length != KeySize)
            {
                return new ArgumentOutOfRangeError(nameof(keyBytes), "Key must have a size of " + KeySize);
            }

            return new Sodium(keyBytes);
        }

        /// <summary>
        /// Encrypts a message using the xsalsa20_poly1305 algorithm.
        /// </summary>
        /// <param name="message">The message to encrypt.</param>
        /// <param name="outputBuffer">Output buffer for the encrypted data.</param>
        /// <param name="nonce">The nonce to use.</param>
        /// <returns>A value indicating if the encryption was successful.</returns>
        public unsafe Result Encrypt(ReadOnlySpan<byte> message, Span<byte> outputBuffer, ReadOnlySpan<byte> nonce)
        {
            if (nonce.Length != NonceSize)
            {
                return new ArgumentOutOfRangeError(nameof(nonce), "The nonce must have a size of " + NonceSize);
            }

            if (outputBuffer.Length != MacSize + message.Length)
            {
                return new ArgumentOutOfRangeError("Output buffer length should be the sum of the sodium MAC size and the message length.");
            }

            bool result = false;

            fixed (byte* messagePtr = message)
            {
                fixed (byte* outputPtr = outputBuffer)
                {
                    fixed (byte* noncePtr = nonce)
                    {
                        fixed (byte* keyPtr = _keyBytes.Span)
                        {
                            result = crypto_secretbox_easy(outputPtr, messagePtr, (ulong)message.Length, noncePtr, keyPtr) == 0;
                        }
                    }
                }
            }

            return !result
                ? new SodiumError("Failed to encrypt.")
                : Result.FromSuccess();
        }
    }
}
